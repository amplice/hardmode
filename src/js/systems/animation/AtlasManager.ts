/**
 * @fileoverview AtlasManager - Manages texture atlases for optimized sprite rendering
 * 
 * This system reduces draw calls by grouping related sprites into texture atlases.
 * Instead of loading 50+ individual PNG files, we load just a few atlas textures.
 */

import * as PIXI from 'pixi.js';

// Atlas configuration
interface AtlasConfig {
    name: string;
    path: string;
    jsonPath: string;
}

// Atlas data structure
interface AtlasData {
    frames: Record<string, {
        frame: { x: number, y: number, w: number, h: number };
        sourceSize: { w: number, h: number };
        spriteSourceSize: { x: number, y: number, w: number, h: number };
    }>;
    meta: {
        image: string;
        size: { w: number, h: number };
        scale: string;
    };
}

export class AtlasManager {
    private atlases: Map<string, PIXI.Texture[]>;
    private textures: Map<string, PIXI.Texture>;
    private loaded: boolean;

    // Define which sprites go into which atlases
    private static readonly ATLAS_CONFIGS: AtlasConfig[] = [
        // Characters atlas (all player classes)
        { 
            name: 'characters', 
            path: 'assets/atlases/characters.png',
            jsonPath: 'assets/atlases/characters.json'
        },
        // Monsters atlas 
        {
            name: 'monsters',
            path: 'assets/atlases/monsters.png', 
            jsonPath: 'assets/atlases/monsters.json'
        },
        // Effects atlas
        {
            name: 'effects',
            path: 'assets/atlases/effects.png',
            jsonPath: 'assets/atlases/effects.json'
        },
        // UI/Powerups atlas
        {
            name: 'ui',
            path: 'assets/atlases/ui.png',
            jsonPath: 'assets/atlases/ui.json'
        }
    ];

    constructor() {
        this.atlases = new Map();
        this.textures = new Map();
        this.loaded = false;
    }

    /**
     * Load all texture atlases
     */
    async loadAtlases(): Promise<void> {
        const loadPromises = AtlasManager.ATLAS_CONFIGS.map(config => 
            this.loadAtlas(config)
        );

        await Promise.all(loadPromises);
        this.loaded = true;
        console.log('[AtlasManager] All atlases loaded successfully');
    }

    /**
     * Load a single texture atlas
     */
    private async loadAtlas(config: AtlasConfig): Promise<void> {
        try {
            // For now, we'll create placeholder atlas data
            // In production, these JSON files would be generated by a texture packing tool
            const atlasData = await this.generatePlaceholderAtlasData(config);
            
            // Load the atlas texture
            const baseTexture = await PIXI.Assets.load(config.path);
            baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;

            // Create textures from atlas data
            for (const [frameName, frameData] of Object.entries(atlasData.frames)) {
                const texture = new PIXI.Texture(
                    baseTexture,
                    new PIXI.Rectangle(
                        frameData.frame.x,
                        frameData.frame.y,
                        frameData.frame.w,
                        frameData.frame.h
                    )
                );
                
                this.textures.set(frameName, texture);
            }

            console.log(`[AtlasManager] Loaded atlas: ${config.name}`);
        } catch (error) {
            console.error(`[AtlasManager] Failed to load atlas ${config.name}:`, error);
            // Fall back to loading sprites individually if atlas fails
            throw error;
        }
    }

    /**
     * Generate placeholder atlas data for testing
     * In production, use a texture packer tool to generate real atlas files
     */
    private async generatePlaceholderAtlasData(config: AtlasConfig): Promise<AtlasData> {
        // For now, return empty atlas data
        // Real implementation would parse the JSON file
        return {
            frames: {},
            meta: {
                image: config.path,
                size: { w: 2048, h: 2048 },
                scale: "1"
            }
        };
    }

    /**
     * Get a texture from the atlases
     */
    getTexture(name: string): PIXI.Texture | undefined {
        return this.textures.get(name);
    }

    /**
     * Get multiple textures (for animations)
     */
    getTextures(names: string[]): PIXI.Texture[] {
        const textures: PIXI.Texture[] = [];
        for (const name of names) {
            const texture = this.textures.get(name);
            if (texture) {
                textures.push(texture);
            }
        }
        return textures;
    }

    /**
     * Check if atlases are loaded
     */
    isLoaded(): boolean {
        return this.loaded;
    }

    /**
     * Create a mapping from individual sprite paths to atlas frame names
     * This allows SpriteManager to work with minimal changes
     */
    createSpriteToAtlasMapping(): Map<string, string> {
        const mapping = new Map<string, string>();
        
        // Map individual sprite paths to atlas frame names
        // Example mappings:
        mapping.set('assets/sprites/characters/Knight/Idle.png', 'knight_idle');
        mapping.set('assets/sprites/characters/Knight/Run.png', 'knight_run');
        mapping.set('assets/sprites/characters/Guardian/Idle.png', 'guardian_idle');
        mapping.set('assets/sprites/monsters/Skeleton/Walk.png', 'skeleton_walk');
        mapping.set('assets/sprites/monsters/Ogre/Idle.png', 'ogre_idle');
        mapping.set('assets/sprites/effects/Slash.png', 'slash_effect');
        
        return mapping;
    }
}