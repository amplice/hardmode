# HARDMODE MULTIPLAYER - DEVELOPMENT ROADMAP
## Complete Implementation Timeline for Multiplayer-First Rebuild

### OVERVIEW

**Total Development Time**: 20-24 weeks (5-6 months)  
**MVP Release**: Week 16  
**Full Release**: Week 24  
**Team Size**: 2-4 developers  

### PHASE 1: FOUNDATION & INFRASTRUCTURE (Weeks 1-4)

#### Week 1: Project Setup & Tooling
**Goal**: Establish development environment and project structure

**Tasks**:
- [ ] Set up monorepo structure with shared TypeScript types
- [ ] Configure build tools (Vite for client, ts-node for server)
- [ ] Implement hot reloading for both client and server
- [ ] Set up Docker development environment
- [ ] Configure ESLint, Prettier, and Git hooks
- [ ] Set up automated testing framework (Jest)
- [ ] Create basic CI/CD pipeline

**ðŸ§ª MANUAL TESTING**: Checkpoint 1 - Server Infrastructure (see MANUAL_TESTING_CHECKPOINTS.md)

**Deliverables**:
```bash\n# Working development commands:\nnpm run dev          # Start both client and server\nnpm run build        # Build for production\nnpm run test         # Run all tests\nnpm run lint         # Code quality checks\n```

**Acceptance Criteria**:\n- Both client and server hot reload on changes\n- Shared types compile correctly\n- Tests run automatically on commit\n- Docker environment works consistently\n\n#### Week 2: Core Networking\n**Goal**: Establish reliable client-server communication\n\n**Tasks**:\n- [ ] Implement Socket.io connection management\n- [ ] Design binary message protocol for high-frequency updates\n- [ ] Create message serialization/deserialization system\n- [ ] Add connection quality monitoring (latency, packet loss)\n- [ ] Implement graceful disconnect/reconnect handling\n- [ ] Add network debugging tools and visualizations\n- [ ] Create latency simulation for development testing\n\n**Key Code**:\n```typescript\n// Network message protocol\nenum MessageType {\n  PLAYER_INPUT = 0x01,     // High frequency (60Hz)\n  POSITION_UPDATE = 0x02,  // Medium frequency (20Hz)\n  STATE_CHANGE = 0x03,     // Event-driven\n  ATTACK_EVENT = 0x04      // Event-driven\n}\n\n// Binary encoding for position updates (12 bytes)\nclass PositionEncoder {\n  static encode(id: number, x: number, y: number): ArrayBuffer\n  static decode(buffer: ArrayBuffer): PositionUpdate\n}\n```\n\n**Acceptance Criteria**:\n- Stable connection with 100ms+ latency\n- Binary messages 50% smaller than JSON\n- Automatic reconnection works reliably\n- Network debug panel shows real-time metrics\n\n#### Week 3: Entity Component System (ECS)\n**Goal**: Build shared ECS foundation for both client and server\n\n**Tasks**:\n- [ ] Implement core Entity and Component classes\n- [ ] Create component serialization/deserialization\n- [ ] Build system architecture with update priorities\n- [ ] Add entity interpolation for smooth client rendering\n- [ ] Implement entity lifecycle management (spawn/despawn)\n- [ ] Create entity querying system for efficient lookups\n- [ ] Add performance profiling for ECS operations\n\n**Key Components**:\n```typescript\n// Core components matching current game\nclass PositionComponent {\n  x: number; y: number;\n  interpolate(other: PositionComponent, alpha: number): void;\n}\n\nclass VelocityComponent {\n  x: number; y: number;\n  magnitude(): number;\n}\n\nclass PlayerComponent {\n  username: string;\n  characterClass: 'bladedancer' | 'guardian' | 'hunter' | 'rogue';\n  level: number;\n  experience: number;\n  facing: DirectionString;\n}\n\nclass HealthComponent {\n  current: number;\n  maximum: number;\n  takeDamage(amount: number): boolean;\n}\n```\n\n**Acceptance Criteria**:\n- ECS handles 100+ entities at 60 FPS\n- Component serialization preserves exact state\n- Client interpolation provides smooth movement\n- Entity queries complete in <1ms\n\n#### Week 4: Basic Game Loop & State Sync\n**Goal**: Core game loop with synchronized state\n\n**Tasks**:\n- [ ] Implement 60Hz server game loop\n- [ ] Create 60 FPS client render loop\n- [ ] Add delta time calculations and frame rate limiting\n- [ ] Implement state broadcasting (server â†’ clients)\n- [ ] Create client state reception and application\n- [ ] Add basic entity spawning and despawning\n- [ ] Implement server tick monitoring and performance metrics\n\n**Core Architecture**:\n```typescript\n// Server game loop\nclass GameLoop {\n  private readonly TICK_RATE = 60;\n  private lastTick = 0;\n  \n  start(): void {\n    setInterval(() => {\n      const now = performance.now();\n      const deltaTime = (now - this.lastTick) / 1000;\n      this.tick(deltaTime);\n      this.lastTick = now;\n    }, 1000 / this.TICK_RATE);\n  }\n  \n  private tick(deltaTime: number): void {\n    this.world.update(deltaTime);\n    this.networkSystem.broadcastUpdates();\n  }\n}\n```\n\n**Acceptance Criteria**:\n- Server maintains stable 60 Hz tick rate under load\n- Client renders at 60 FPS consistently\n- State synchronization has <50ms latency\n- No memory leaks after 1 hour of operation\n\n### PHASE 2: CORE GAMEPLAY (Weeks 5-8)\n\n#### Week 5: Player Movement & Input\n**Goal**: Implement client prediction with server validation\n\n**Tasks**:\n- [ ] Create input capture system (WASD + mouse)\n- [ ] Implement client-side movement prediction\n- [ ] Add server-side movement validation\n- [ ] Build server reconciliation system\n- [ ] Implement the exact movement mechanics from current game:\n  - [ ] Forward movement: 100% speed\n  - [ ] Strafing: 70% speed\n  - [ ] Backward movement: 50% speed\n  - [ ] Diagonal movement: 85% speed\n  - [ ] Class-specific speeds (Rogue: 6, Hunter/Bladedancer: 5, Guardian: 3.5)\n- [ ] Add mouse-based 8-directional facing\n- [ ] Implement movement interpolation for remote players\n\n**Movement Implementation**:\n```typescript\n// Client prediction\nclass ClientPrediction {\n  processInput(input: InputState): void {\n    // Send to server\n    this.network.sendInput(input);\n    \n    // Apply locally immediately\n    this.applyMovement(this.localPlayer, input);\n    \n    // Store for reconciliation\n    this.inputBuffer.push(input);\n  }\n  \n  reconcile(serverState: GameState): void {\n    // Check prediction accuracy\n    const error = this.calculatePositionError(serverState);\n    \n    if (error > RECONCILIATION_THRESHOLD) {\n      this.rollbackAndReplay(serverState);\n    }\n  }\n}\n\n// Server validation\nclass MovementValidator {\n  validateInput(player: Entity, input: InputState): boolean {\n    const maxSpeed = this.getClassSpeed(player.class) * LAG_TOLERANCE;\n    const predictedSpeed = this.calculateSpeed(input);\n    \n    return predictedSpeed <= maxSpeed;\n  }\n}\n```\n\n**Acceptance Criteria**:\n- Movement feels responsive with 100ms latency\n- Speed validation prevents cheating\n- Reconciliation is imperceptible for normal movement\n- All movement modifiers match current game exactly\n\n#### Week 6: World Generation & Collision\n**Goal**: Deterministic world with server-authoritative collision\n\n**Tasks**:\n- [ ] Port world generation to use fixed seeds\n- [ ] Implement deterministic simplex noise\n- [ ] Create the exact world generation from current game:\n  - [ ] 100Ã—100 tile world (6400Ã—6400 pixels)\n  - [ ] Grass, sand, water terrain types\n  - [ ] Noise-based generation with cleanup passes\n  - [ ] Transition tile processing\n  - [ ] Decoration placement\n- [ ] Add server-side collision detection\n- [ ] Implement wall sliding mechanics\n- [ ] Create collision map for efficient lookups\n- [ ] Add world boundary enforcement\n\n**World Generation**:\n```typescript\nclass DeterministicWorldGenerator {\n  constructor(private seed: number) {\n    this.noise = new SimplexNoise(seed);\n  }\n  \n  generate(): WorldData {\n    // Exact algorithm from current game\n    const tiles = this.generateBaseTerrain();\n    this.cleanupIsolatedSand(tiles, 3); // cardinalCleanup: 3\n    this.generateWater(tiles);\n    this.cleanupGrassPeninsulas(tiles);\n    this.cleanupThinWaterConnections(tiles, 2); // waterCleanup: 2\n    this.processTransitions(tiles);\n    \n    return { width: 100, height: 100, tileSize: 64, tiles, seed };\n  }\n}\n```\n\n**Acceptance Criteria**:\n- Same seed generates identical worlds\n- Water tiles block movement correctly\n- Wall sliding feels natural\n- World generation completes in <1 second\n\n#### Week 7: Combat System Foundation\n**Goal**: Server-authoritative combat with lag compensation\n\n**Tasks**:\n- [ ] Implement attack input handling\n- [ ] Create server-side hitbox system\n- [ ] Add lag compensation for combat\n- [ ] Build attack timing validation\n- [ ] Implement the exact attack system from current game:\n  - [ ] Rectangle hitboxes (blade attacks)\n  - [ ] Cone hitboxes (sweeping attacks)\n  - [ ] Circle hitboxes (area attacks)\n  - [ ] Projectile system (Hunter arrows)\n- [ ] Add attack cooldown management\n- [ ] Create visual effect synchronization\n- [ ] Implement damage application and health changes\n\n**Combat Implementation**:\n```typescript\nclass CombatSystem {\n  processAttack(attacker: Entity, attackType: string, timestamp: number): void {\n    // Get exact config from current game\n    const config = ATTACK_CONFIGS[`${attacker.class}_${attackType}`];\n    \n    // Validate timing\n    if (!this.validateAttackTiming(attacker, config)) return;\n    \n    // Apply lag compensation\n    const compensatedTime = timestamp - this.getPlayerLatency(attacker.id);\n    const historicalPositions = this.hitHistory.getAt(compensatedTime);\n    \n    // Schedule attack execution\n    setTimeout(() => {\n      this.executeAttack(attacker, config, historicalPositions);\n    }, config.windupTime);\n  }\n  \n  private executeAttack(attacker: Entity, config: AttackConfig, positions: PositionMap): void {\n    const hitbox = this.createHitbox(positions.get(attacker.id), config);\n    const hits = this.checkHits(hitbox, positions, attacker.id);\n    \n    for (const hit of hits) {\n      this.applyDamage(hit.target, config.damage);\n    }\n  }\n}\n```\n\n**Acceptance Criteria**:\n- Attacks hit consistently with 100ms latency\n- All hitbox shapes work exactly like current game\n- Attack timing matches current game precisely\n- Visual effects sync with actual damage\n\n#### Week 8: Character Classes & Abilities\n**Goal**: All 4 character classes with exact abilities\n\n**Tasks**:\n- [ ] Implement Bladedancer class:\n  - [ ] Primary: Rectangle hitbox (85Ã—45), 1 damage, 133ms windup\n  - [ ] Secondary: Rectangle hitbox (110Ã—70), 2 damage, 500ms windup\n  - [ ] Roll: 150 unit dash, 300ms duration\n- [ ] Implement Guardian class:\n  - [ ] Primary: Cone hitbox (110 range, 110Â° angle), 1 damage\n  - [ ] Secondary: Jump attack (circle 75 radius), 2 damage, invulnerable\n  - [ ] Roll: Standard dash\n- [ ] Implement Hunter class:\n  - [ ] Primary: Projectile (700 speed, 600 range), precise mouse aiming\n  - [ ] Secondary: Backward jump + cone attack\n  - [ ] Roll: Standard dash\n- [ ] Implement Rogue class:\n  - [ ] Primary: Rectangle hitbox (95Ã—30), 1 damage\n  - [ ] Secondary: Dash attack (200 unit dash with damage)\n  - [ ] Roll: Standard dash\n- [ ] Add class selection UI\n- [ ] Implement exact stat differences (HP, speed)\n\n**Class Implementation**:\n```typescript\n// Exact values from current game\nconst CLASS_CONFIGS = {\n  bladedancer: {\n    hitPoints: 3,\n    moveSpeed: 5,\n    attacks: {\n      primary: {\n        damage: 1,\n        windupTime: 133,\n        hitbox: { type: 'rectangle', width: 45, length: 85 }\n      },\n      secondary: {\n        damage: 2,\n        windupTime: 500,\n        hitbox: { type: 'rectangle', width: 70, length: 110 }\n      }\n    }\n  },\n  guardian: {\n    hitPoints: 4,\n    moveSpeed: 3.5,\n    attacks: {\n      primary: {\n        damage: 1,\n        windupTime: 250,\n        hitbox: { type: 'cone', range: 110, angle: 110 }\n      },\n      secondary: {\n        damage: 2,\n        windupTime: 150,\n        hitbox: { type: 'circle', radius: 75 },\n        special: 'jump_attack'\n      }\n    }\n  }\n  // ... hunter and rogue configs\n};\n```\n\n**Acceptance Criteria**:\n- All classes feel identical to current single-player game\n- Attack timings and damages match exactly\n- Special abilities (jumps, dashes) work correctly\n- Class selection UI is functional\n\n### PHASE 3: ADVANCED FEATURES (Weeks 9-12)\n\n#### Week 9: Monster AI & PvE\n**Goal**: Server-controlled monster AI with exact behaviors\n\n**Tasks**:\n- [ ] Implement monster AI state machine (idle, pursuing, attacking, stunned, dying)\n- [ ] Create the exact 5 monster types from current game:\n  - [ ] Skeleton: 2 HP, 2.5 speed, 70 range, 5 XP\n  - [ ] Elemental: 3 HP, 2 speed, 100 range, circle attack, 10 XP\n  - [ ] Ogre: 4 HP, 2 speed, 90 range, wide cone, 20 XP\n  - [ ] Ghoul: 2 HP, 3.5 speed, 70 range, 15 XP\n  - [ ] Wild Archer: 1 HP, 3 speed, 500 range, projectiles, 10 XP\n- [ ] Add pathfinding with A* algorithm\n- [ ] Implement line-of-sight detection\n- [ ] Create monster spawning system (300 max, spawn every 1 second)\n- [ ] Add monster attack patterns matching current game\n- [ ] Implement aggro ranges and target acquisition\n\n**Monster AI**:\n```typescript\nclass MonsterAI {\n  update(monster: Entity, deltaTime: number): void {\n    switch (monster.aiState) {\n      case 'idle':\n        this.updateIdle(monster);\n        break;\n      case 'pursuing':\n        this.updatePursuing(monster, deltaTime);\n        break;\n      case 'attacking':\n        this.updateAttacking(monster);\n        break;\n    }\n  }\n  \n  private updatePursuing(monster: Entity, deltaTime: number): void {\n    const target = this.world.getEntity(monster.targetId);\n    if (!target) {\n      monster.aiState = 'idle';\n      return;\n    }\n    \n    const distance = this.calculateDistance(monster, target);\n    \n    if (distance <= monster.attackRange) {\n      monster.aiState = 'attacking';\n      this.scheduleAttack(monster);\n    } else if (this.hasLineOfSight(monster, target)) {\n      this.moveToward(monster, target, deltaTime);\n    } else {\n      this.followPath(monster, target, deltaTime);\n    }\n  }\n}\n```\n\n**Acceptance Criteria**:\n- Monster behaviors match current game exactly\n- AI performance supports 300 concurrent monsters\n- Pathfinding handles complex terrain\n- Monster attacks feel fair and consistent\n\n#### Week 10: Experience & Progression\n**Goal**: Level system with exact progression curve\n\n**Tasks**:\n- [ ] Implement XP gain from monster kills (no PvP XP)\n- [ ] Create exact leveling curve (Level Ã— 20 XP per level)\n- [ ] Add level-up bonuses matching current game:\n  - [ ] Level 2 & 6: +0.25 movement speed\n  - [ ] Level 3 & 7: -25ms attack recovery\n  - [ ] Level 4 & 8: -100ms ability cooldown\n  - [ ] Level 5: Unlock roll ability\n  - [ ] Level 10: +1 maximum HP\n- [ ] Implement kill count tracking\n- [ ] Add level-up visual effects\n- [ ] Create progression persistence\n- [ ] Add death/respawn system (keep progression)\n\n**Progression System**:\n```typescript\nclass ProgressionSystem {\n  awardExperience(player: Entity, monster: Entity): void {\n    const xpGain = MONSTER_XP_VALUES[monster.type];\n    player.experience += xpGain;\n    \n    this.checkLevelUp(player);\n  }\n  \n  private checkLevelUp(player: Entity): void {\n    const xpRequired = this.getXpForLevel(player.level + 1);\n    \n    while (player.experience >= xpRequired && player.level < 10) {\n      player.level++;\n      this.applyLevelBonus(player);\n      player.health.current = player.health.maximum; // Full heal\n      \n      // Broadcast level up\n      this.world.broadcast('player:levelup', {\n        playerId: player.id,\n        newLevel: player.level\n      });\n    }\n  }\n  \n  private getXpForLevel(level: number): number {\n    // Exact formula: level * 20\n    return level * 20;\n  }\n}\n```\n\n**Acceptance Criteria**:\n- XP curve matches current game exactly\n- Level bonuses apply correctly\n- Progression persists through death\n- Level-up effects are satisfying\n\n#### Week 11: PvP Combat & Balancing\n**Goal**: Player vs Player combat with class balance\n\n**Tasks**:\n- [ ] Enable PvP damage between players\n- [ ] Implement damage stun (0.25 second) exactly like current game\n- [ ] Add invulnerability frames during specific abilities\n- [ ] Balance class interactions:\n  - [ ] Guardian: Tank but vulnerable to kiting\n  - [ ] Hunter: High damage but fragile\n  - [ ] Rogue: Fast but low HP\n  - [ ] Bladedancer: Balanced all-around\n- [ ] Implement death/respawn at world center\n- [ ] Add PvP event broadcasting\n- [ ] Create combat logging for balance analysis\n- [ ] Test all class matchups extensively\n\n**PvP Implementation**:\n```typescript\nclass PvPSystem {\n  processPvPHit(attacker: Entity, target: Entity, damage: number): void {\n    // Apply damage\n    const died = target.health.takeDamage(damage);\n    \n    // Apply damage stun\n    target.stunTimer = 0.25; // Exact value from current game\n    target.canMove = false;\n    target.canAttack = false;\n    \n    if (died) {\n      this.handlePlayerDeath(target, attacker);\n    }\n    \n    // Broadcast PvP event\n    this.world.broadcast('pvp:hit', {\n      attacker: attacker.id,\n      target: target.id,\n      damage,\n      died\n    });\n  }\n  \n  private handlePlayerDeath(victim: Entity, killer: Entity): void {\n    // Respawn at world center\n    victim.position.x = WORLD_WIDTH / 2 * TILE_SIZE;\n    victim.position.y = WORLD_HEIGHT / 2 * TILE_SIZE;\n    victim.health.current = victim.health.maximum;\n    victim.isDead = false;\n  }\n}\n```\n\n**Acceptance Criteria**:\n- PvP feels balanced and skill-based\n- All class abilities work in PvP\n- Death/respawn system works smoothly\n- Combat feels responsive and fair\n\n#### Week 12: Performance Optimization\n**Goal**: Support 100+ concurrent players\n\n**Tasks**:\n- [ ] Implement spatial partitioning for entity queries\n- [ ] Add area-of-interest management (players only see nearby entities)\n- [ ] Optimize network message frequency and size\n- [ ] Implement entity interpolation and extrapolation\n- [ ] Add object pooling for frequently created objects\n- [ ] Optimize collision detection with spatial hashing\n- [ ] Profile and optimize hot code paths\n- [ ] Add server performance monitoring\n\n**Performance Optimizations**:\n```typescript\n// Spatial partitioning\nclass SpatialGrid {\n  private readonly CELL_SIZE = 200; // 200 pixels per cell\n  private cells = new Map<string, Set<Entity>>();\n  \n  getEntitiesInRadius(center: Position, radius: number): Entity[] {\n    const cellRadius = Math.ceil(radius / this.CELL_SIZE);\n    const entities: Entity[] = [];\n    \n    // Check only relevant cells\n    for (let dx = -cellRadius; dx <= cellRadius; dx++) {\n      for (let dy = -cellRadius; dy <= cellRadius; dy++) {\n        const cell = this.getCell(center.x + dx * this.CELL_SIZE, center.y + dy * this.CELL_SIZE);\n        entities.push(...cell);\n      }\n    }\n    \n    return entities.filter(e => this.distanceTo(center, e.position) <= radius);\n  }\n}\n\n// Area of interest\nclass AOIManager {\n  getVisibleEntities(player: Entity): Entity[] {\n    const VIEW_DISTANCE = 800; // Pixels\n    return this.spatialGrid.getEntitiesInRadius(player.position, VIEW_DISTANCE);\n  }\n}\n```\n\n**Acceptance Criteria**:\n- Server maintains 60 Hz with 100+ players\n- Client renders at 60 FPS consistently\n- Network usage scales linearly with player count\n- Memory usage remains stable over time\n\n### PHASE 4: POLISH & RELEASE (Weeks 13-16)\n\n#### Week 13: UI/UX & Visual Polish\n**Goal**: Complete user interface and visual experience\n\n**Tasks**:\n- [ ] Create main menu and class selection screen\n- [ ] Implement in-game HUD (health, stats, level)\n- [ ] Add visual effects for all abilities\n- [ ] Implement smooth camera following\n- [ ] Create particle effects for impacts and deaths\n- [ ] Add audio system (sound effects and music)\n- [ ] Implement screen shake and game juice\n- [ ] Create loading screens and transitions\n\n#### Week 14: Testing & Bug Fixes\n**Goal**: Comprehensive testing and stability\n\n**Tasks**:\n- [ ] Automated testing for all game systems\n- [ ] Load testing with 100+ concurrent players\n- [ ] Network stability testing with various conditions\n- [ ] Cross-browser compatibility testing\n- [ ] Memory leak detection and fixes\n- [ ] Performance profiling and optimization\n- [ ] Security testing and validation\n- [ ] Accessibility improvements\n\n#### Week 15: Deployment Infrastructure\n**Goal**: Production-ready deployment\n\n**Tasks**:\n- [ ] Set up production servers with auto-scaling\n- [ ] Configure load balancing and health checks\n- [ ] Implement monitoring and alerting\n- [ ] Set up automated deployments\n- [ ] Configure SSL certificates and security\n- [ ] Add server region selection\n- [ ] Implement graceful shutdowns and updates\n- [ ] Create admin tools and dashboards\n\n#### Week 16: Launch Preparation & MVP Release\n**Goal**: MVP launch with core features\n\n**Tasks**:\n- [ ] Final performance optimization\n- [ ] Launch preparation and stress testing\n- [ ] Community setup (Discord, forums)\n- [ ] Documentation and player guides\n- [ ] Marketing material preparation\n- [ ] Launch event planning\n- [ ] Post-launch monitoring setup\n- [ ] **MVP RELEASE**\n\n### PHASE 5: POST-LAUNCH EXPANSION (Weeks 17-24)\n\n#### Weeks 17-18: Content Expansion\n- Additional monster types\n- Equipment system foundation\n- Guild/clan basic features\n- Tournament system\n\n#### Weeks 19-20: Advanced Features\n- Spectator mode\n- Replay system\n- Advanced statistics\n- Seasonal events\n\n#### Weeks 21-22: Gameplay Enhancements\n- New character classes\n- Boss monsters\n- Dungeon instances\n- Achievement system\n\n#### Weeks 23-24: Platform Expansion\n- Mobile client\n- Steam integration\n- Mod support\n- **FULL RELEASE**\n\n### DEVELOPMENT RESOURCES\n\n#### Team Structure\n**Minimum Team (2 developers)**:\n- Lead Developer: Full-stack, multiplayer networking expertise\n- Game Developer: Client-side, PIXI.js, game mechanics\n\n**Optimal Team (4 developers)**:\n- Lead Developer: Architecture, networking, server systems\n- Backend Developer: Node.js, ECS, AI systems\n- Frontend Developer: PIXI.js, UI/UX, client optimization\n- DevOps Engineer: Infrastructure, deployment, monitoring\n\n#### Technology Requirements\n- **Development**: High-performance laptops with 16GB+ RAM\n- **Testing**: Multiple devices for compatibility testing\n- **Infrastructure**: Cloud servers for load testing and deployment\n- **Tools**: Professional IDE licenses, monitoring tools\n\n#### Success Metrics\n\n**Technical KPIs**:\n- Server maintains 60 Hz tick rate with 100+ players\n- Client renders at 60 FPS on target hardware\n- Average latency <100ms for 95% of players\n- 99.9% uptime after month 1\n\n**Gameplay KPIs**:\n- Average session time >20 minutes\n- Player retention >60% after 1 week\n- Class distribution within 20-30% for each class\n- Active PvP engagement >50% of playtime\n\n**Business KPIs**:\n- 1000+ concurrent players at peak\n- Positive community sentiment\n- Sustainable server costs\n- Ready for content expansion\n\nThis roadmap provides a comprehensive path to successfully rebuild Hardmode as a multiplayer-first game while maintaining the exact gameplay experience of the original single-player version.