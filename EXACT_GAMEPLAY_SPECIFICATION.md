# HARDMODE - EXACT GAMEPLAY SPECIFICATION
## Precise Implementation Details for Multiplayer Rebuild

### EXECUTIVE SUMMARY

This document captures the exact gameplay mechanics, values, and behaviors from the current single-player Hardmode game. Every number, timing, and interaction detailed here must be preserved precisely in the multiplayer rebuild to maintain the identical gameplay experience.

### CHARACTER CLASSES - EXACT SPECIFICATIONS

#### Bladedancer
```typescript
const BLADEDANCER_CONFIG = {
  hitPoints: 3,
  moveSpeed: 5,
  spritePrefix: 'knight',
  baseColor: 0x3498db,
  
  attacks: {
    primary: {
      name: "Slash Attack",
      damage: 1,
      windupTime: 133,           // milliseconds
      recoveryTime: 200,
      cooldown: 100,
      hitboxType: 'rectangle',
      hitboxParams: { width: 45, length: 85 },
      effectSequence: [
        { type: 'slash_effect', timing: 250 }
      ]
    },
    secondary: {
      name: "Smash Attack", 
      damage: 2,
      windupTime: 500,
      recoveryTime: 300,
      cooldown: 800,
      hitboxType: 'rectangle',
      hitboxParams: { width: 70, length: 110 },
      effectSequence: [
        { type: 'strike_windup', timing: 100 },
        { type: 'strike_cast', timing: 500 }
      ]
    },
    roll: {
      name: "Roll",
      damage: 0,
      windupTime: 50,
      dashDuration: 300,
      recoveryTime: 150,
      cooldown: 1000,
      dashDistance: 150,
      invulnerable: false
    }
  },
  
  animations: {
    idle: { speed: 0.2 },
    run: { speed: 0.5 },
    run_backward: { speed: 0.5 },
    strafe_left: { speed: 0.5 },
    strafe_right: { speed: 0.5 },
    attack1: { speed: 0.4, hitFrame: 8 },
    attack2: { speed: 0.3, hitFrame: 12 },
    roll: { speed: 0.5 },
    die: { speed: 0.2 },
    take_damage: { speed: 0.5 }
  }
};\n```\n\n#### Guardian\n```typescript\nconst GUARDIAN_CONFIG = {\n  hitPoints: 4,\n  moveSpeed: 3.5,\n  spritePrefix: 'guardian',\n  baseColor: 0xe74c3c,\n  \n  attacks: {\n    primary: {\n      name: \"Sweeping Axe\",\n      damage: 1,\n      windupTime: 250,\n      recoveryTime: 300,\n      cooldown: 200,\n      hitboxType: 'cone',\n      hitboxParams: { range: 110, angle: 110 },\n      effectSequence: [\n        { type: 'guardian_slash_effect', timing: 250 }\n      ]\n    },\n    secondary: {\n      name: \"Jump Attack\",\n      damage: 2,\n      windupTime: 150,\n      jumpDuration: 325,\n      recoveryTime: 200,\n      cooldown: 1250,\n      dashDistance: 200,\n      invulnerable: true,\n      hitboxType: 'circle',\n      hitboxParams: { radius: 75 },\n      effectSequence: [\n        { \n          type: 'guardian_jump_effect',\n          timing: 475,\n          useStartPosition: false\n        }\n      ],\n      actionPointDelay: 325\n    }\n  },\n  \n  animations: {\n    idle: { speed: 0.15 },\n    run: { speed: 0.4 },\n    run_backward: { speed: 0.4 },\n    strafe_left: { speed: 0.4 },\n    strafe_right: { speed: 0.4 },\n    attack1: { speed: 0.35, hitFrame: 8 },\n    attack2: { speed: 0.35, hitFrame: 12 },\n    roll: { speed: 0.5 },\n    die: { speed: 0.2 },\n    take_damage: { speed: 0.5 }\n  }\n};\n```\n\n#### Hunter\n```typescript\nconst HUNTER_CONFIG = {\n  hitPoints: 1,\n  moveSpeed: 5,\n  spritePrefix: 'hunter',\n  baseColor: 0x2ecc71,\n  \n  attacks: {\n    primary: {\n      name: \"Bow Shot\",\n      damage: 1,\n      windupTime: 100,\n      recoveryTime: 100,\n      cooldown: 100,\n      archetype: 'projectile',\n      projectileSpeed: 700,\n      projectileRange: 600,\n      projectileOffset: 30,\n      projectileVisualEffectType: 'bow_shot_effect',\n      usesMouseAiming: true  // Precise mouse targeting\n    },\n    secondary: {\n      name: \"Retreat Shot\",\n      damage: 2,\n      windupTime: 150,\n      jumpDuration: 300,\n      recoveryTime: 200,\n      cooldown: 800,\n      dashDistance: 200,\n      jumpHeight: 50,\n      backwardJump: true,     // Jumps backward from facing\n      attackFromStartPosition: true,\n      hitboxType: 'cone',\n      hitboxParams: { range: 80, angle: 70 },\n      effectSequence: [\n        {\n          type: 'hunter_cone_effect',\n          timing: 250,\n          distance: 50,\n          useStartPosition: true\n        }\n      ],\n      actionPointDelay: 50\n    }\n  },\n  \n  animations: {\n    idle: { speed: 0.2 },\n    run: { speed: 0.5 },\n    run_backward: { speed: 0.5 },\n    strafe_left: { speed: 0.5 },\n    strafe_right: { speed: 0.5 },\n    attack1: { speed: 0.5, hitFrame: 8 },\n    attack2: { speed: 0.5, hitFrame: 12 },\n    roll: { speed: 0.5 },\n    die: { speed: 0.2 },\n    take_damage: { speed: 0.5 }\n  }\n};\n```\n\n#### Rogue\n```typescript\nconst ROGUE_CONFIG = {\n  hitPoints: 2,\n  moveSpeed: 6,\n  spritePrefix: 'rogue',\n  baseColor: 0x9b59b6,\n  \n  attacks: {\n    primary: {\n      name: \"Thrust Attack\",\n      damage: 1,\n      windupTime: 133,\n      recoveryTime: 200,\n      cooldown: 100,\n      hitboxType: 'rectangle',\n      hitboxParams: { width: 30, length: 95 },\n      effectSequence: [\n        { type: 'rogue_thrust_effect', timing: 133 }\n      ]\n    },\n    secondary: {\n      name: \"Dash Attack\",\n      damage: 1,\n      windupTime: 50,\n      dashDuration: 200,\n      recoveryTime: 150,\n      cooldown: 2000,\n      dashDistance: 200,\n      invulnerable: false,\n      hitboxType: 'rectangle',\n      hitboxParams: { width: 50, length: 200 },\n      effectSequence: [\n        { type: 'rogue_dash_effect', timing: 50 }\n      ]\n    }\n  },\n  \n  animations: {\n    idle: { speed: 0.25 },\n    run: { speed: 0.6 },\n    run_backward: { speed: 0.6 },\n    strafe_left: { speed: 0.6 },\n    strafe_right: { speed: 0.6 },\n    attack1: { speed: 0.5, hitFrame: 7 },\n    attack2: { speed: 0.4, hitFrame: 10 },\n    roll: { speed: 0.5 },\n    die: { speed: 0.25 },\n    take_damage: { speed: 0.6 }\n  }\n};\n```\n\n### MOVEMENT MECHANICS - EXACT VALUES\n\n#### Speed Calculation\n```typescript\nclass MovementSystem {\n  calculateMovement(input: InputState, player: PlayerComponent): Vector2 {\n    let vx = 0, vy = 0;\n    \n    // Basic directional input\n    if (input.up) vy = -1;\n    if (input.down) vy = 1;\n    if (input.left) vx = -1;\n    if (input.right) vx = 1;\n    \n    // Diagonal movement factor (EXACT: 0.85, not 0.7071)\n    if (vx !== 0 && vy !== 0) {\n      const diagonalFactor = 0.85;\n      vx *= diagonalFactor;\n      vy *= diagonalFactor;\n    }\n    \n    // Calculate facing vs movement angle\n    const facingAngle = this.getFacingAngle(player.facing);\n    const movementAngle = (vx !== 0 || vy !== 0) ? Math.atan2(vy, vx) : facingAngle;\n    \n    let angleDiff = Math.abs(facingAngle - movementAngle);\n    if (angleDiff > Math.PI) {\n      angleDiff = 2 * Math.PI - angleDiff;\n    }\n    \n    // Speed modifiers based on movement direction\n    let speedModifier = 1.0;\n    if (angleDiff < Math.PI / 4) {\n      speedModifier = 1.0;    // Forward: 100%\n    } else if (angleDiff > 3 * Math.PI / 4) {\n      speedModifier = 0.5;    // Backward: 50%\n    } else {\n      speedModifier = 0.7;    // Strafing: 70%\n    }\n    \n    // Apply final velocity\n    const baseSpeed = this.getClassSpeed(player.characterClass);\n    return {\n      x: vx * baseSpeed * speedModifier,\n      y: vy * baseSpeed * speedModifier\n    };\n  }\n  \n  private getClassSpeed(characterClass: string): number {\n    const speeds = {\n      'bladedancer': 5,\n      'guardian': 3.5,\n      'hunter': 5,\n      'rogue': 6\n    };\n    return speeds[characterClass] || 5;\n  }\n}\n```\n\n#### Facing System\n```typescript\n// Character faces mouse cursor in 8 directions\nfunction angleToDirectionString(angleInDegrees: number): string {\n  // Normalize angle to 0-360\n  let angle = angleInDegrees;\n  while (angle < 0) angle += 360;\n  while (angle >= 360) angle -= 360;\n  \n  // Convert to 8-directional facing\n  if (angle >= 337.5 || angle < 22.5) return 'right';\n  if (angle >= 22.5 && angle < 67.5) return 'down-right';\n  if (angle >= 67.5 && angle < 112.5) return 'down';\n  if (angle >= 112.5 && angle < 157.5) return 'down-left';\n  if (angle >= 157.5 && angle < 202.5) return 'left';\n  if (angle >= 202.5 && angle < 247.5) return 'up-left';\n  if (angle >= 247.5 && angle < 292.5) return 'up';\n  if (angle >= 292.5 && angle < 337.5) return 'up-right';\n  \n  return 'down'; // Default\n}\n\n// Calculate mouse angle relative to screen center\nfunction updateFacingFromMouse(mousePosition: Point): string {\n  const dx = mousePosition.x - window.innerWidth / 2;\n  const dy = mousePosition.y - window.innerHeight / 2;\n  const angleInDegrees = Math.atan2(dy, dx) * 180 / Math.PI;\n  \n  return angleToDirectionString(angleInDegrees);\n}\n```\n\n### MONSTER SPECIFICATIONS - EXACT VALUES\n\n#### Monster Stats\n```typescript\nconst MONSTER_STATS = {\n  ogre: {\n    hitPoints: 4,\n    moveSpeed: 2,\n    attackRange: 90,\n    collisionRadius: 35,\n    aggroRange: 800,\n    xp: 20,\n    attack: {\n      windup: 0.5,\n      duration: 0.2,\n      recovery: 0.8,\n      cooldown: 1.5,\n      pattern: 'cone',\n      coneAngleDegrees: 110,\n      color: 0x885500,\n      damage: 1\n    },\n    animations: {\n      walk: { speed: 0.3 },\n      idle: { speed: 0.2 },\n      attack1: { speed: 0.25, hitFrame: 9 },\n      take_damage: { speed: 0.7 },\n      die: { speed: 0.2 }\n    }\n  },\n  \n  skeleton: {\n    hitPoints: 2,\n    moveSpeed: 2.5,\n    attackRange: 70,\n    collisionRadius: 15,\n    aggroRange: 1200,\n    xp: 5,\n    attack: {\n      windup: 0.3,\n      duration: 0.2,\n      recovery: 0.6,\n      cooldown: 0.7,\n      pattern: 'cone',\n      coneAngleDegrees: 70,\n      color: 0xEEEEEE,\n      damage: 1\n    },\n    animations: {\n      walk: { speed: 0.4 },\n      idle: { speed: 0.2 },\n      attack1: { speed: 0.3, hitFrame: 8 },\n      take_damage: { speed: 0.7 },\n      die: { speed: 0.5 }\n    }\n  },\n  \n  elemental: {\n    hitPoints: 3,\n    moveSpeed: 2,\n    attackRange: 100,\n    collisionRadius: 15,\n    aggroRange: 800,\n    xp: 10,\n    attack: {\n      windup: 0.4,\n      duration: 0.3,\n      recovery: 0.5,\n      cooldown: 2.5,\n      pattern: 'circle',\n      color: 0x42C0FB,\n      damage: 1\n    },\n    animations: {\n      walk: { speed: 0.4 },\n      idle: { speed: 0.2 },\n      attack1: { speed: 0.3, hitFrame: 8 },\n      take_damage: { speed: 0.7 },\n      die: { speed: 0.2 }\n    }\n  },\n  \n  ghoul: {\n    hitPoints: 2,\n    moveSpeed: 3.5,\n    attackRange: 70,\n    collisionRadius: 10,\n    aggroRange: 3000,  // Very long aggro range\n    xp: 15,\n    attack: {\n      windup: 0.2,\n      duration: 0.2,\n      recovery: 0.3,\n      cooldown: 0.4,\n      pattern: 'cone',\n      color: 0x7CFC00,\n      damage: 1\n    },\n    animations: {\n      walk: { speed: 0.45 },\n      idle: { speed: 0.25 },\n      attack1: { speed: 0.4, hitFrame: 7 },\n      take_damage: { speed: 0.7 },\n      die: { speed: 0.25 }\n    }\n  },\n  \n  wildarcher: {\n    hitPoints: 1,\n    moveSpeed: 3,\n    attackRange: 500,\n    collisionRadius: 15,\n    aggroRange: 1500,\n    xp: 10,\n    attack: {\n      windup: 0.4,\n      duration: 0.2,\n      recovery: 0.4,\n      cooldown: 1.5,\n      pattern: 'projectile',\n      projectileSpeed: 600,\n      projectileRange: 500,\n      color: 0xAAFFAA,\n      damage: 1,\n      projectileEffect: 'wildarcher_shot_effect'\n    },\n    animations: {\n      walk: { speed: 0.4 },\n      idle: { speed: 0.2 },\n      attack1: { speed: 0.35, hitFrame: 8 },\n      take_damage: { speed: 0.7 },\n      die: { speed: 0.3 }\n    }\n  }\n};\n```\n\n#### Monster Spawn System\n```typescript\nconst MONSTER_SPAWN_CONFIG = {\n  timer: 1,                    // 1 second between spawn attempts\n  maxMonsters: 300,            // Maximum concurrent monsters\n  minDistanceFromPlayer: 700,  // Minimum spawn distance from any player\n  maxDistanceFromPlayer: 10000, // Maximum spawn distance\n  distribution: {\n    skeleton: 0.2,   // 20% chance\n    elemental: 0.2,  // 20% chance\n    ghoul: 0.2,      // 20% chance\n    ogre: 0.2,       // 20% chance\n    wildarcher: 0.2  // 20% chance\n  }\n};\n```\n\n### PROGRESSION SYSTEM - EXACT VALUES\n\n#### Experience Formula\n```typescript\nclass ProgressionSystem {\n  // XP required to reach a specific level\n  getTotalXpForLevel(level: number): number {\n    // Formula: (level - 1) * level / 2 * 20\n    return (level - 1) * level / 2 * 20;\n  }\n  \n  // XP needed for next level specifically\n  getXpForNextLevel(currentLevel: number): number {\n    return currentLevel * 20;\n  }\n  \n  // Apply level bonuses (EXACT implementation)\n  applyLevelBonus(player: PlayerComponent, level: number): void {\n    switch (level) {\n      case 2:\n      case 6:\n        player.moveSpeed += 0.25;\n        break;\n        \n      case 3:\n      case 7:\n        this.modifyAttackRecovery(player, -25); // -25ms\n        break;\n        \n      case 4:\n      case 8:\n        this.modifyAttackCooldown(player, -100); // -100ms\n        break;\n        \n      case 5:\n        player.rollUnlocked = true;\n        break;\n        \n      case 9:\n        // Future ability unlock (currently unused)\n        break;\n        \n      case 10:\n        player.maxHitPoints += 1;\n        break;\n    }\n  }\n}\n```\n\n#### Level Progression Table\n```\nLevel 1: 0 XP total (start)\nLevel 2: 20 XP total (20 XP needed)\nLevel 3: 60 XP total (40 XP needed)\nLevel 4: 120 XP total (60 XP needed)\nLevel 5: 200 XP total (80 XP needed) - Roll unlocked\nLevel 6: 300 XP total (100 XP needed)\nLevel 7: 420 XP total (120 XP needed)\nLevel 8: 560 XP total (140 XP needed)\nLevel 9: 720 XP total (160 XP needed)\nLevel 10: 900 XP total (180 XP needed) - +1 HP\n```\n\n### WORLD GENERATION - EXACT ALGORITHM\n\n#### World Parameters\n```typescript\nconst WORLD_CONFIG = {\n  width: 100,        // tiles\n  height: 100,       // tiles\n  tileSize: 64,      // pixels\n  \n  noise: {\n    terrain: 0.05,   // Terrain noise frequency\n    water: 0.08      // Water noise frequency\n  },\n  \n  thresholds: {\n    sand: -0.3,             // Noise value below which terrain becomes sand\n    water: -0.5,            // Noise value below which water generates\n    sandDistance: 3,        // Minimum distance from sand for water\n    cardinalCleanup: 3,     // Cardinal neighbors needed to convert sand to grass\n    waterCleanup: 2,        // Water neighbors needed to keep water tile\n    sandCleanup: 5          // (unused in current implementation)\n  }\n};\n```\n\n#### Generation Algorithm\n```typescript\nclass WorldGenerator {\n  generate(): WorldData {\n    // 1. Create world boundary (green background)\n    this.createWorldBoundary();\n    \n    // 2. Generate base terrain (grass and sand)\n    this.generateBaseTerrain();\n    \n    // 3. Clean up isolated sand tiles\n    this.cleanupIsolatedSand(3); // cardinalCleanup threshold\n    \n    // 4. Generate water\n    this.generateWater();\n    \n    // 5. Clean up water formations\n    this.cleanupGrassPeninsulas();\n    this.cleanupThinWaterConnections(2); // waterCleanup threshold\n    \n    // 6. Process terrain transitions\n    this.processTransitions();\n    \n    // 7. Process water transitions\n    this.processWaterTransitions();\n    \n    // 8. Generate decorations\n    this.generateDecorations();\n    \n    return this.worldData;\n  }\n  \n  private generateBaseTerrain(): void {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        const noiseValue = this.noise2D(x * 0.05, y * 0.05);\n        const terrainType = noiseValue < -0.3 ? 'sand' : 'grass';\n        this.tiles[y][x] = new Tile(x, y, terrainType);\n      }\n    }\n  }\n}\n```\n\n### DAMAGE & HEALTH SYSTEM\n\n#### Damage Mechanics\n```typescript\nconst DAMAGE_CONFIG = {\n  stunDuration: 0.25,  // seconds - EXACT value when taking damage\n  flashDuration: 0.1   // seconds - red tint duration\n};\n\nclass HealthSystem {\n  takeDamage(entity: Entity, amount: number): boolean {\n    const health = entity.getComponent<HealthComponent>('health');\n    \n    health.current -= amount;\n    \n    // Apply damage stun (EXACT: 0.25 seconds)\n    entity.stunTimer = 0.25;\n    entity.canMove = false;\n    entity.canAttack = false;\n    \n    // Check for death\n    if (health.current <= 0) {\n      this.handleDeath(entity);\n      return true; // Entity died\n    }\n    \n    return false; // Entity survived\n  }\n  \n  respawn(entity: Entity): void {\n    const health = entity.getComponent<HealthComponent>('health');\n    const position = entity.getComponent<PositionComponent>('position');\n    \n    // Reset health to maximum\n    health.current = health.maximum;\n    \n    // Respawn at world center (EXACT coordinates)\n    position.x = (WORLD_WIDTH / 2) * TILE_SIZE;   // 50 * 64 = 3200\n    position.y = (WORLD_HEIGHT / 2) * TILE_SIZE;  // 50 * 64 = 3200\n    \n    // Reset states\n    entity.isDead = false;\n    entity.isDying = false;\n    entity.isAttacking = false;\n    entity.stunTimer = 0;\n  }\n}\n```\n\n### INPUT SYSTEM - EXACT MAPPING\n\n```typescript\nconst INPUT_MAPPING = {\n  movement: {\n    up: 'KeyW',\n    left: 'KeyA',\n    down: 'KeyS',\n    right: 'KeyD'\n  },\n  combat: {\n    primaryAttack: 'MouseLeft',    // Left mouse button\n    secondaryAttack: 'Space',      // Space bar\n    roll: 'ShiftLeft'              // Left shift (unlocked at level 5)\n  },\n  mouse: {\n    facing: true,                  // Mouse position determines facing\n    aiming: true                   // Mouse position used for Hunter precision\n  }\n};\n\nclass InputSystem {\n  update(): InputState {\n    return {\n      // Movement (WASD)\n      up: this.keys.w,\n      left: this.keys.a,\n      down: this.keys.s,\n      right: this.keys.d,\n      \n      // Combat\n      primaryAttack: this.mouse.leftButton,\n      secondaryAttack: this.keys.space,\n      roll: this.keys.shift,\n      \n      // Mouse state\n      mousePosition: {\n        x: this.mouse.position.x,\n        y: this.mouse.position.y\n      }\n    };\n  }\n}\n```\n\n### VISUAL EFFECTS - EXACT SPECIFICATIONS\n\n```typescript\nconst VISUAL_EFFECTS = {\n  slash_effect: {\n    scale: 1.5,\n    offsetDistance: 60,\n    rotationOffset: 0,\n    animationSpeed: 0.5,\n    followDuration: 0,\n    flipX: false,\n    flipY: true\n  },\n  \n  guardian_slash_effect: {\n    scale: 2,\n    offsetDistance: 70,\n    rotationOffset: Math.PI / 2,  // 90 degrees\n    animationSpeed: 0.6,\n    followDuration: 0,\n    flipX: true,\n    flipY: true\n  },\n  \n  guardian_jump_effect: {\n    scale: 3.5,\n    offsetDistance: 0,            // Centered on player\n    rotationOffset: 0,\n    animationSpeed: 0.5,\n    followDuration: 0,\n    flipX: false,\n    flipY: false\n  },\n  \n  rogue_thrust_effect: {\n    scale: 1.8,\n    offsetDistance: 50,\n    rotationOffset: -Math.PI / 4, // -45 degrees\n    animationSpeed: 0.4,\n    followDuration: 0,\n    flipX: false,\n    flipY: false\n  },\n  \n  bow_shot_effect: {\n    scale: 1.0,\n    offsetDistance: 30,\n    rotationOffset: 0,\n    animationSpeed: 0.3,\n    followDuration: 0,\n    flipX: false,\n    flipY: false\n  },\n  \n  level_up_effect: {\n    scale: 1.5,\n    offsetDistance: 0,            // Centered on player\n    rotationOffset: 0,\n    animationSpeed: 0.2,\n    followDuration: 1000,         // Follows player for 1 second\n    flipX: false,\n    flipY: false\n  }\n};\n```\n\n### PHYSICS & COLLISION - EXACT BEHAVIOR\n\n```typescript\nclass PhysicsSystem {\n  update(deltaTime: number, entities: Entity[]): void {\n    for (const entity of entities) {\n      this.updatePosition(entity, deltaTime);\n      this.checkCollisions(entity);\n    }\n  }\n  \n  private updatePosition(entity: Entity, deltaTime: number): void {\n    const position = entity.getComponent<PositionComponent>('position');\n    const velocity = entity.getComponent<VelocityComponent>('velocity');\n    \n    // Apply movement\n    const newX = position.x + velocity.x * deltaTime;\n    const newY = position.y + velocity.y * deltaTime;\n    \n    // Check world boundaries\n    const boundedX = Math.max(0, Math.min(newX, WORLD_WIDTH * TILE_SIZE));\n    const boundedY = Math.max(0, Math.min(newY, WORLD_HEIGHT * TILE_SIZE));\n    \n    // Check tile collision\n    if (this.isValidPosition(boundedX, boundedY)) {\n      position.x = boundedX;\n      position.y = boundedY;\n    } else {\n      // Try wall sliding\n      if (this.isValidPosition(boundedX, position.y)) {\n        position.x = boundedX; // Slide horizontally\n      }\n      if (this.isValidPosition(position.x, boundedY)) {\n        position.y = boundedY; // Slide vertically\n      }\n    }\n    \n    // Round to prevent floating point drift\n    position.x = Math.round(position.x);\n    position.y = Math.round(position.y);\n  }\n  \n  private isValidPosition(x: number, y: number): boolean {\n    const tileX = Math.floor(x / TILE_SIZE);\n    const tileY = Math.floor(y / TILE_SIZE);\n    \n    // Check bounds\n    if (tileX < 0 || tileX >= WORLD_WIDTH || tileY < 0 || tileY >= WORLD_HEIGHT) {\n      return false;\n    }\n    \n    // Check if tile is walkable (not water)\n    const tile = this.world.getTile(tileX, tileY);\n    return tile.type !== 'water';\n  }\n}\n```\n\n### CAMERA SYSTEM - EXACT BEHAVIOR\n\n```typescript\nclass CameraSystem {\n  update(player: Entity): void {\n    const position = player.getComponent<PositionComponent>('position');\n    \n    // Camera follows player exactly\n    this.camera.x = position.x;\n    this.camera.y = position.y;\n    \n    // Update world container position (centered on screen)\n    this.worldContainer.position.set(\n      Math.floor(this.screenWidth / 2 - this.camera.x),\n      Math.floor(this.screenHeight / 2 - this.camera.y)\n    );\n    \n    // Update entity container position (same as world)\n    this.entityContainer.position.set(\n      Math.floor(this.screenWidth / 2 - this.camera.x),\n      Math.floor(this.screenHeight / 2 - this.camera.y)\n    );\n  }\n}\n```\n\n### TESTING REQUIREMENTS\n\nTo verify the multiplayer rebuild matches the original exactly:\n\n1. **Movement Tests**:\n   - All speed modifiers (forward 100%, strafe 70%, backward 50%)\n   - Diagonal movement factor (0.85)\n   - Class-specific speeds\n   - Mouse-based facing accuracy\n\n2. **Combat Tests**:\n   - All attack timings match within ±5ms\n   - Hitbox shapes and sizes exact\n   - Damage values precise\n   - Cooldowns accurate\n\n3. **Progression Tests**:\n   - XP formula correctness\n   - Level bonus application\n   - Monster XP values\n\n4. **World Tests**:\n   - Same seed generates identical worlds\n   - Collision detection matches\n   - Tile types and transitions correct\n\n5. **Visual Tests**:\n   - Effect positions and timings\n   - Animation speeds\n   - Camera behavior\n\nThis specification document ensures that every aspect of the multiplayer rebuild preserves the exact gameplay experience of the original single-player Hardmode game.